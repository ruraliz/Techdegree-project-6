const express = require('express'); //require express depedency 

const app = express();
// create our app variable


//serve static files 
app.use('/static', express.static('public'));

//setting view engine to pug 
app.set('view engine', 'pug');
//The views property defines the directory where the template files are located.

//routes 
const mainRoutes = require('./routes');
app.use(mainRoutes)
//We will next define our server in another file: index.js and import the routes defined in the file: routes.js. 


//We can optionally pass a path to the middleware, which will only handle requests to that route. 
//request, and response, also called the Handler Function. 
//error Handler for 404 and other errors 

app.use((req, res, next) => {
  const err = new Error("Not Found");
  err.status = 404; 
  next(err); //
});

// route handler and middleware invokes an asynchronous function which in turn produces some errors, then we have to explicitly pass the error to the next() function, where Express will catch and process them. However, in the above code, the error is not the part of the synchronous code, so we canâ€™t simply pass it to the next function. We need to first throw the errors, catch those errors generated by asynchronous code, and then pass it to the Express. 

app.use((err, req, res, next) => {
  if(err.status === 404){
      res.status(404);
      err.status = 404;
      err.message = " This page was not found";
      res.render('page-not-found', {err});
  } else {
      err.status =  err.status || 500;
      console.log(err.status);
      err.message = err.message || 'Internal Server Error';
      res.render('error', {err});
  }
})


app.listen(3000, () => {
    console.log('The application is running on localhost:3000!')
});

//We are passing 3000 into the listen function, which tells the app which port to listen on. The function passed in as the second parameter is optional and runs when the server starts up. This provides us some feedback in the console to know that our application is running.




